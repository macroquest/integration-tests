|***
 *
 * MacroQuest2
 * TLO.Member testing
 *
 *
 *
 *
 ***|


#warning
#turbo 200

#define OUT "/echo -"
#define LOG "/mqlog"
#define GOOD "\agpass\ax"
#define BAD "\arfail\ax"
#define INC "\ayincomplete\ax"
#define SKIP "\amskip\ax"


#include TestSuite\RequirementsTest.inc
#include TestSuite\MQ2MacroType.inc
#include TestSuite\MQ2CharacterType.inc
#include TestSuite\MQ2GroupType.inc
#include TestSuite\MQ2RaidType.inc
#include TestSuite\MQ2ClassType.inc
#include TestSuite\MQ2TimeType.inc
#include TestSuite\MQ2FellowshipType.inc
| #include TestSuite\MQ2CachedBuffType.inc
| #include TestSuite\MQ2TargetBuffType.inc
| #include TestSuite\
| #include TestSuite\
| #include TestSuite\
| #include TestSuite\
| #include TestSuite\
| #include TestSuite\
| #include TestSuite\
| #include TestSuite\
| #include TestSuite\
| #include TestSuite\
| #include TestSuite\
| #include TestSuite\





sub main(Param0)

	/mqclear

	/echo

	| set some outer variables
	| these will be used all over the place.
	| outer string (yes i know it's a long word)
	/declare outerString string outer OuterStringOUTERSTRING
	| outer int
	/declare outerInt int outer 999999
	| outer bool
	/declare outerBool bool outer TRUE
	| swap var for bind
	/declare swap bool FALSE

	| hide visual PASSing tests
	/declare hidePass bool outer FALSE

	| fake a Param if one is not pased
	/if (!${Bool[${Param0}]}) {
		/varset Param0 bob
	}

	| test the requirements, no skipping this!
	/call start_RequirementsTest


	/declare TLO[1] string outer
	/varset TLO[1] |Macro|Group|Character|Fellowship|Bandolier|CachedBuff|TargetBuff|Class|Time

	/call echo_info
	/while (TRUE) {
		| inf loop for knightly!!
		/varset swap ${If[${swap},FALSE,TRUE]}
		/delay 5
	}

/return




|**
 * outputs results to screen and log
 * /invoke ${out[pass|fail|inc|skip, MEMBER, expected type of data, ${TLO.MEMBER}]}
 **|
sub out(string _gb, string _name, string _expect, string _got)

	/if (${_gb.Equal[good]}) {
		LOG ..${_name} .. pass
		/if (!${hidePass}) {
			OUT ..${_name} .. GOOD
		}
	} else /if (${_gb.Equal[bad]}) {
		LOG ..${_name} .. FAIL.. expect:${_expect} got:${_got}
		OUT ..\aw${_name}\ax .. BAD
		OUT ....expect: \at${_expect}\ax ....got: \at${_got}\ax
	} else /if (${_gb.Equal[inc]}) {
		LOG ..${_name} .. incomplete.. unable to test on this run
		OUT ..\aw${_name}\ax .. INC
		OUT ....expect: \at${_expect}\ax ....got: \at${_got}\ax
	} else /if (${_gb.Equal[skip]}) {
		LOG ..${_name} .. skip.. no test for this
		OUT ..\aw${_name}\ax .. SKIP
	}

	/if (${_gb.Equal[inc]}) {
		/delay 5
	} else /if (${_gb.Equal[bad]}) {
		/delay 2s
	} else /if (!${hidePass}) {
		/delay 1
	}

/return



|**
 * simply returns the default outer string
 **|
sub test_return_string()
 | empty
/return ${outerString}



|**
 * bind for testing specific TLOs (no tlo passed = all)
 **|
#Bind control_ts /ts
sub Bind_control_ts(string tlo)

	/if (${Bool[${tlo}]}) {
		/if (${SubDefined[start_MQ2${tlo}Type]}) {
			/call start_MQ2${tlo}Type
		} else /if (!${SubDefined[start_MQ2${tlo}Type]}) {
			OUT Invalid::\a-wstart_MQ2${tlo}Type\ax
		}
	} else {
		/declare x int local 0
		/declare y int local 0

		| loop throuh the tlo array
		/for x 1 to ${TLO.Size}
			/for y 1 to ${TLO[${x}].Count[|]}
				/call start_MQ2${TLO[${x}].Arg[${y},|]}Type
			/next y
		/next x
	}

	/call echo_info

/return


|**
 * output basic info for the user
 **|
sub echo_info()

	/echo
	OUT TLOs
	| output the TLO list fopr peeps
	/declare x int local 0
	/for x 1 to ${TLO.Size}
		OUT \a-w${TLO[${x}]}\ax
	/next x

	OUT \aw/ts TLONAME\ax (default:\a-tall\ax)
	OUT ... waiting on you ...

/return

