|***
 *
 * MacroQuest2
 * TLO.Member testing
 *
 *
 *
 *
 ***|


#warning
#turbo 200

#define OUT "/echo -"
#define LOG "/mqlog"
#define GOOD "\agpass\ax"
#define BAD "\arfail\ax"
#define INC "\ayincomplete\ax"
#define SKIP "\amskip\ax"


#include TestSuite\RequirementsTest.inc
#include TestSuite\MQ2StringType.inc
#include TestSuite\MQ2MacroType.inc
#include TestSuite\MQ2CharacterType.inc
#include TestSuite\MQ2GroupType.inc
#include TestSuite\MQ2RaidType.inc
#include TestSuite\MQ2ClassType.inc
#include TestSuite\MQ2TimeType.inc
#include TestSuite\MQ2FellowshipType.inc
#include TestSuite\MQ2CachedBuffType.inc
#include TestSuite\MQ2TargetBuffType.inc
#include TestSuite\MQ2BandolierType.inc
#include TestSuite\MQ2FriendsType.inc
#include TestSuite\MQ2DeityType.inc
| #include TestSuite\MQ2WorldLocationType.inc
#include TestSuite\MQ2RaceType.inc
#include TestSuite\MQ2MacroQuestType.inc
#include TestSuite\MQ2ArrayType.inc
| #include TestSuite\MQ2GroundType.inc
#include TestSuite\MQ2BodyType.inc
#include TestSuite\MQ2FloatType.inc
| #include TestSuite\MQ2DoubleType.inc
#include TestSuite\MQ2IntType.inc

#include TestSuite\MQ2MathType.inc




sub main(Param0)

	/mqclear

	/echo

	| set some outer variables
	| these will be used all over the place.
	| outer string (yes i know it's a long word)
	/declare myString string outer MyStringMYSTRING

	| outer int
	/declare outerInt int outer 999999

	| outer bool
	/declare outerBool bool outer TRUE

	| swap var for bind
	/declare swap bool FALSE

	| hide visual PASSing tests
	/declare hidePass bool outer FALSE

	| set max lvl. don't want to hardcode this in a bunch of places
	/declare maxLevel int outer 115

	| fake a Param if one is not passed
	/if (!${Bool[${Param0}]}) {
		/varset Param0 bob
	}

	| test the requirements, no skipping this!
	/call start_RequirementsTest

	| establish the array for all the TLOs we will be using
	| this will also be used in the ArrayType test
	/declare TLO[3] string outer
	/varset TLO[1] |Macro|Group|Character|Fellowship|Bandolier|CachedBuff|TargetBuff|Class
	/varset TLO[2] |Time|Friends|Deity|Race|MacroQuest|String|Array|Body
	/varset TLO[3] |Math|Float|Int


	| WorldLocation

	/call echo_info

	| wait for user input
	/while (TRUE) {
		| inf loop for knightly!!
		/varset swap ${If[${swap},FALSE,TRUE]}
		/delay 5
	}

/return




|**
 * outputs results to screen and log
 * /invoke ${out[pass|fail|inc|skip|echo, MEMBER, expected type of data, ${TLO.MEMBER}]}
 **|
sub out(string _gb, string _name, string _expect, string _got)

	| result is good, yay us!
	/if (${_gb.Equal[good]}) {
		LOG ..${_name} .. pass
		/if (!${hidePass}) {
			OUT ..${_name} .. GOOD
		}

	| result is bad. make a note, and move on
	} else /if (${_gb.Equal[bad]}) {
		LOG ..${_name} .. FAIL.. expect:${_expect} got:${_got}
		OUT ..\aw${_name}\ax .. BAD
		OUT ....expect: \at${_expect}\ax ....got: \at${_got}\ax

	| test is invomplete for some reason
	} else /if (${_gb.Equal[inc]}) {
		LOG ..${_name} .. incomplete.. unable to test on this run
		OUT ..\aw${_name}\ax .. INC
		OUT ....expect: \at${_expect}\ax ....got: \at${_got}\ax

	| skip this, we canot test in current environment
	} else /if (${_gb.Equal[skip]}) {
		LOG ..${_name} .. skip.. no test for this
		OUT ..\aw${_name}\ax .. SKIP

	| some form of simple conversions where you just need to echo the data
	} else /if (${_gb.Equal[echo]}) {
		LOG ..${_name} .. just an echo for continuity
		OUT ..${_name} .. \at${_got}\ax
	}

	/if (${_gb.Equal[inc]}) {
		/delay 5
	} else /if (${_gb.Equal[bad]}) {
		/delay 2s
	} else /if (!${hidePass}) {
		/delay 1
	}

/return



|**
 * simply returns the default outer string
 **|
sub test_return_string()
 | empty
/return ${myString}



|**
 * bind for testing specific TLOs (no tlo passed = all)
 **|
#Bind control_ts /ts
sub Bind_control_ts(string tlo)

	/if (${Bool[${tlo}]}) {
		/if (${SubDefined[start_MQ2${tlo}Type]}) {
			/call start_MQ2${tlo}Type
		} else /if (!${SubDefined[start_MQ2${tlo}Type]}) {
			OUT Invalid::\a-wstart_MQ2${tlo}Type\ax
		}
	} else {
		/declare x int local 0
		/declare y int local 0

		| loop throuh the tlo array
		/for x 1 to ${TLO.Size}
			/for y 1 to ${TLO[${x}].Count[|]}
				/call start_MQ2${TLO[${x}].Arg[${y},|]}Type
			/next y
		/next x
	}

	/call echo_info

/return


|**
 * output basic info for the user
 **|
sub echo_info()

	/declare x int local 0
	/declare y int local 0
	/declare output string local

	/echo
	OUT TLOs
	| output the TLO list for peeps
	/for x 1 to ${TLO.Size}
		/for y 1 to ${TLO[${x}].Count[|]}
			/varset output ${output} \a-w${TLO[${x}].Arg[${y},|]}\ax${If[${y}==${TLO[${x}].Count[|]},,,]}
		/next y
		OUT ${output}
		/varset output
	/next x

	/echo

	OUT \aw/ts TLONAME\ax (default:\a-tall\ax)
	OUT ... waiting on you ...

/return

